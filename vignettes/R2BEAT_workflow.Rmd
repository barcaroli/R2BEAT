---
title: "R2BEAT two-stage sampling design workflow starting from a previous survey" 
date: "`r Sys.Date()` <br>  <br> <br>"
output: 
  bookdown::html_document2:
    df_print: kable
    highlight: tango
    number_sections: yes
    theme: flatly
    toc: yes
    toc_depth: 2
    toc_float:
      collapsed: no
      smooth_scroll: yes
    toc_title: 
    # code_folding: hide
keep_md: TRUE
#bibliography: 
#link-citations: yes
#linkcolor: red
vignette: >
  %\VignetteIndexEntry{R2BEAT two-stage sampling design workflow starting from a previous survey}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

```{r setup, include=FALSE}
options(width=400) 
knitr::opts_chunk$set(echo = TRUE, fig.width=6, fig.height=4)
# Install ReGenesees if not already installed
  if (requireNamespace("ReGenesees", quietly = TRUE)) {
    svystat    <- ReGenesees::svystat
  } else {
    stop("The package ReGenesees is needed. \nInstall it by executing the following: \ndevtools::install_github('DiegoZardetto/ReGenesees')")
  }
library(ReGenesees)
library(R2BEAT)
#library(plyr)
library(sampling)
options(warn=-1)
options(scipen=9999)
```

This vignette describes a generalized procedure making use of the methods implemented in the R package developed in the Italian National Institute, namely R2BEAT ("Multistage Sampling Allocation and PSU selection").

This package allows to determine the optimal allocation of both Primary Stage Units (PSUs) and Secondary Stage Units (SSU), and also to perform a selection of the PSUs such that the final sample of SSU is of the self-weighting type, i.e. the total inclusion probabilities (as resulting from the product between the inclusion probabilities of the PSUs and those of the SSUs) are near equal for all SSUs, or at least those of minimum variability.

This general flow assumes that at least a previous round of the survey, whose sampling design has to be optimized, is available, and is characterized by the following steps:

# Use of ReGenesees

Perform externally the definition of the sample design, and possibly of the calibration step, using the R package ReGenesees, and make the design object and the calibrated object available.

The workspace to be loaded (R2BEAT_ReGenesees.RData) is available at the link:

<https://github.com/barcaroli/R2BEAT/tree/master/data>

```{r}
load("R2BEAT_ReGenesees.RData")   # ReGenesees design object
```

This is the 'design' object:

```{r}
des
```

and this is the calibrated object:

```{r}
cal
```

It is advisable to check the presence of lonely strata:

```{r}
# Control the presence of strata with less than two units
ls <- find.lon.strata(des)
```

In case, provide to collapse and re-do the calibration.

In this example, in the ReGenesees objects there are the following variables:

```{r}
str(des$variables)
```

where there are three potential target variables:

1.  income_hh (numeric);
2.  work (factor with values 0, 1, 2);
3.  unemployed (factor with values 0, 1).

```{r}
summary(des$variables$income_hh)
```

```{r}
table(des$variables$work)
```

```{r}
table(des$variables$unemployed)
```

Great attention must be paid to the nature of the target variables, especially of the 'factor' type. In fact, the procedure here illustrated is suitable only when categorical variables are binary with values 0 and 1, supposing we are willing to estimate proportions of '1' in the population. If factor variables are of other nature, then an error message is printed.


# Build 'strata', 'deff', 'effst' and 'rho' dataframes

Using ReGenesees objects as input, produce the following dataframes (function 'input_to_beat.2st_1'):

a)  the 'stratif' dataframe containing:

-   STRATUM: identifier of the single stratum
-   N: total population in terms of final sampling units
-   Mi,Si: mean and standard deviation of target variables (i=1,2,..,P)
-   DOMk: domain(s) to which the stratum belongs

b)  the 'deff' (design effect) dataframe, containing the following information:

-   STRATUM: the stratum identifier
-   DEFFi: the design effect for each target variable i (i=1,2,...,P)

c)  the 'effst' (estimator effect) dataframe, containing the following information:

-   STRATUM: the stratum identifier
-   EFFSTi: the estimator effect for each target variable i (i=1,2,...,P)

d)  the 'rho' (intraclass coefficient of correlation) dataframe, containing the following information:

-   STRATUM: the stratum identifier
-   RHO_ARi: the intraclass coefficient of correlation in self-representative PSUs for each target variable i (i=1,2,...,P)
-   RHO_NARi: the intraclass coefficient of correlation in non self-representative PSUs for each target variable i (i=1,2,...,P)

Actually, the 'deff' dataframe is not used in the following steps, it just remains for documentation purposes.

Here is the way we can produce the above items:

```{r}
load("pop.RData")
samp_frame <- pop
RGdes <- des
RGcal <- cal
strata_var <- c("stratum")      
target_vars <- c("income_hh",
                 "active",
                 "inactive",
                 "unemployed")   
weight_var <- "weight"
deff_var <- "stratum"            
id_PSU <- c("municipality")      
id_SSU <- c("id_hh")             
domain_var <- c("region") 
delta <- 1                   
minimum <- 50                

inp <- prepareInputToAllocation2(
        samp_frame,  # sampling frame
        RGdes,       # ReGenesees design object
        RGcal,       # ReGenesees calibrated object
        id_PSU,      # identification variable of PSUs
        id_SSU,      # identification variable of SSUs
        strata_var,  # strata variables
        target_vars, # target variables
        deff_var,    # deff variables
        domain_var,  # domain variables
        delta,       # Average number of SSUs for each selection unit
        minimum      # Minimum number of SSUs to be selected in each PSU
      )
```

and these are the results:

```{r}
head(inp$strata)
```

```{r}
head(inp$deff)
```

```{r}
head(inp$effst)
```

```{r}
head(inp$rho)
```
```{r}
head(inp$psu_file)
```

```{r}
head(inp$des_file)
```


# Check the coherence of populations in strata and PSUs

It may happen that the population in strata (variable 'N' in 'inp1\$strata' dataset) and the one derived by the PSU dataset (variable 'STRAT_MOS' in 'inp2\$des_file' dataset) are not the same.

We can check it by applying the function 'check_input' in this way:

```{r}
newstrata <- check_input(strata=inp$strata,
                         des=inp$des_file,
                         strata_var_strata="STRATUM",
                         strata_var_des="STRATUM")

```

Together with the print of the differences between the two populations, the function produces a new version of the strata dataset, where the population has been changed to the one derived by the PSUs dataset.

It is preferable to use this new version:

```{r}
inp$strata <- newstrata
```

# Optimal allocation of units in each stratum

Using the function 'beat.2st' in 'R2BEAT' package execute the optimization of PSU and SSU allocation in strata:

```{r}
cv <- as.data.frame(list(DOM=c("DOM1","DOM2"),
                         CV1=c(0.02,0.03),
                         CV2=c(0.03,0.05),
                         CV3=c(0.03,0.05),
                         CV4=c(0.05,0.08)))
cv
```

```{r}
set.seed(1234)
minPSUstrat <- 2
inp$des_file$MINIMUM <- 50
alloc <- beat.2st(stratif = inp$strata, 
                  errors = cv, 
                  des_file = inp$des_file, 
                  psu_file = inp$psu_file, 
                  rho = inp$rho, 
                  deft_start = NULL, 
                  effst = inp$effst, 
                  minnumstrat = 2, 
                  minPSUstrat)
```

This is the sensitivity of the solution:

```{r}
alloc$sensitivity
```

i.e., for each domain value and for each variable it is reported the gain in terms of reduction in the sample size if the corresponding precision constraint is reduced of 10%.

These are the expected values of the coefficients of variation:

```{r}
alloc$expected
```

# Selection of PSUs

Using the function 'select_SSU' execute the selection of PSU in strata:

```{r}
set.seed(1234)
sample_1st <- select_PSU(alloc, type="ALLOC", pps=TRUE, plot=TRUE)
```

This is the overall sample design:

```{r}
sample_1st$PSU_stats
```

# Selection of SSUs

Finally, we are able to select the Secondary Sample Units (the individuals) from the already selected PSUs (the municipalities). We proceed to select the sample in this way:

```{r}
samp <- select_SSU(df=pop,
                   PSU_code="municipality",
                   SSU_code="id_ind",
                   PSU_sampled=sample_1st$sample_PSU,
                   verbose=FALSE)
```

To check that the total amount is practically equal to what determined in the allocation step:

```{r}
nrow(samp)
sum(alloc$alloc$ALLOC[-nrow(alloc$alloc)])
```

and that the sum of weights equalize population size:

```{r}
nrow(pop)
sum(samp$weight)
```

This is the distribution of weights:

```{r}
par(mfrow=c(1, 2))
boxplot(samp$weight,col="orange")
title("Weights distribution (total sample)",cex.main=0.7)
boxplot(weight ~ region, data=samp,col="orange")
title("Weights distribution by region",cex.main=0.7)
boxplot(weight ~ province, data=samp,col="orange")
title("Weights distribution by province",cex.main=0.7)
boxplot(weight ~ stratum, data=samp,col="orange")
title("Weights distribution by stratum",cex.main=0.7)
```

It can be seen that the sample is fully self-weighted inside strata, and approximately self-weighted in aggregations of strata, that is the result we wanted to obtain.

```{r, include=FALSE}
   # add this chunk to end of mycode.rmd
   file.rename(from="R2BEAT_workflow.md", 
               to="out.md")
```
